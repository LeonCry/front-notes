//算法描述:[快速排序简称快排,一般取第一个数作为基准数,所以快]
//递归排序,通过一趟排序将要排序的数据分割成独立的两部分(没说这两部分长度一定一样,可以不一样),
//其中一部分的数据要比另一部分的所有数据小,然后再按照此方法对分成的两边再次排序
//P:根据哪个数来划分成独立的两部分?:数组中的哪个数都可以,一般取第一个数
//P:根据这个基准数怎么划分成独立的两部分?:从整个数组分为左侧索引和右侧索引慢慢的向中间靠拢,靠拢的过程是这样的:
// 左侧索引开始向右移动,当某一处的值比基准值大了,就停止,右侧索引开始向左移动,当某一处的值比基准值小了,就将这两个值进行交换,然后重复
// 当左侧索引和右侧索引相遇了,此时就将基准值放到相遇的位置,即原本相遇位置的值与基准位置的值交换即可.
// 然后在左侧和右侧再次进行快排,直到最后只剩一个值.

//实现
// @ts-nocheck
const QuickSort = (arr) => {
  let left = 0;
  let right = arr.length - 1;
  quick(arr,left,right);
  return arr;
}

const quick = (arr,left,right) => {
  //需要移动的左侧索引
  let l = left;
  //需要移动的右侧索引
  let r = right;
  //基准值
  let base = arr[left];
  //递归尽头,递归的最后左右子数组只剩下一个值的时候,就停止递归了
  if (left>=right) return;
  //左侧索引和右侧索引开始进行内聚移动,注意,移动的时候要时刻注意左侧索引和右侧索引的值,避免left>right越界
  while(l<r){
    //为什么要先从右侧开始? => 因为如果先从左侧开始的话,左侧最后停止的位置一定是大于基准数的,那么到最后与基准数进行交换的时候,
    //大于基准数的数字就跑到了最左边,明显不能正确的分割成左右两个子数组
    //右侧索引位置的值比基准值大,并且两边索引未相遇,则右侧索引--;
    while(arr[r]>=base&&l<r) r--;
    //左侧索引位置的值比基准值小,并且两边索引未相遇,则左侧索引++;
    while(arr[l]<=base&&l<r) l++;
    //当运行到这里的时候,说明左侧索引位置的值大于基准值且右侧索引的值小于基准值  或者l>=r了,两侧索引相遇了
    //如果是第一种情况,那就将两侧的值进行互换
    if(l<r){
      let temp = arr[l];
      arr[l] = arr[r];
      arr[r] = temp;
    }
    else{
      //如果是第二种情况,两侧相遇了,则将基准值与当前值进行互换
      arr[left] = arr[l];
      arr[l] = base;
    }
  }
  //根据基准值将两边分区完毕,此时需要递归,再次对两边分区进行快排
  quick(arr,left,r-1);
  quick(arr,r+1,right);
}






const arr = [25,14,21,9,30,18,6,0,12,15,27,6,10,33];
console.log(QuickSort(arr));