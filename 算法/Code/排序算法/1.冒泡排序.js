// 算法描述:[因为每次都会将最大的数放到最后,就像水里冒泡一样,所以叫冒泡排序]
// 比较相邻的元素。如果第一个比第二个大，就交换它们两个.然后比较第二个与第三个...直到最后;
// 重新开始,针对所有的元素重复以上的步骤.

// 实现
// @ts-nocheck
const bubbleSort = (arr) => {
  //此处循环为整体循环次数
  for (let i = 0; i < arr.length; i++) {
    //优化点:let finish = true;
    //此处循环为相邻元素的比较
    //为什么要-1-i: -1是因为在循环到最后一个数的时候没有j+1了,所以不用比较;
    //-i是因为每次循环后,最大的都会被排到最后面,所以最后面的其实不用再比较了;
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j+1]<arr[j]) {
        let temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
        //优化点:finish = false;
      }
    }
    //优化点:finish?break:null;
  }
  return arr;
}


const arr = [25,14,21,9,30,18,6,0,12,15,27,6,10,33];
console.log(bubbleSort(arr));

//冒泡排序还有一个可以优化的地方:
//那就是每次循环的时候都会进行比较,但是如果在某次排序中已经将arr排序完毕了,那么以后就没必要再比较了,可以提前结束,
//所以可以设置一个boolean值进行监控


//算法分析:最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)