// 算法描述:[其实我认为更应该叫分区插入排序.因为他的工作原理是将arr分为两个区,一个已排区,一个未排区,
// 从未派区里挨个找然后和已排区的数比较,找准自己的位置然后插入,所以叫插入排序]
// 插入排序是从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；
// 直到该元素找到自己的位置,进行插入,一直重复,直到未排区的数据量为0为止.

// 实现
// @ts-nocheck
const insertionSort = (arr) => {
  //这个变量是已排区的大小长度
  let sortedLength = 1;
  //这个循环是未排区的循环
  for (let j = sortedLength; j < arr.length; j++) {
    //未排区的第一个数的值(这里不能用下标,因为下标在已排区插入的时候会被覆盖)
    let curValue = arr[j];
    // 这个循环是已排区的循环,每次从未排区拿到数据后都要在已排区里进行插入,注意是从后向前排
    for (let i = sortedLength - 1; i >= 0; i--) {
      //如果未排区的值小于当前已排区的值,那么已排区的值应该向后退,未排区的值向前进
      if(curValue<arr[i]){
        arr[i+1] = arr[i];
      }
      //否则,就是未排区的值大于了当前的值,那么就将未排区的值放到刚才的前一个位置上(i+1).
      else{
        arr[i+1] = curValue;
        break;
      }
      //如果已经排到头了,说明未排区的当前值就是最小值,直接插到最顶端
      if(i===0){
        arr[i] = curValue;
      }
    }
    sortedLength++;
  }
  return arr;
}



const arr = [25,14,21,9,30,18,6,0,12,15,27,6,10,33];
console.log(insertionSort(arr));

//算法分析:最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2)